{"title":"DDIA_Chapter1","slug":"DDIA-Chapter1","date":"2025-03-14T08:29:36.000Z","updated":"2025-05-05T04:30:44.384Z","comments":true,"path":"api/articles/DDIA-Chapter1.json","photos":[],"excerpt":"第一章 可靠性，可伸缩性，可维护性现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。但现在合称为数据系统。近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，如数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）单个工具不足以满足所有的数据处理和存储需求，总体工作将被拆分成一系列单个足以高效完成的任务，然后用应用代码将它们缝合起来。然后隐藏实现细节，提供服务的接口或者API。","covers":["/../Asset/DDIA_Chapter1/DDIA.png"],"content":"<h1 id=\"第一章-可靠性，可伸缩性，可维护性\"><a href=\"#第一章-可靠性，可伸缩性，可维护性\" class=\"headerlink\" title=\"第一章 可靠性，可伸缩性，可维护性\"></a>第一章 可靠性，可伸缩性，可维护性</h1><p>现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。</p>\n<p>我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。但现在合称为数据系统。</p>\n<ul>\n<li><p>近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，如数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）</p>\n</li>\n<li><p>单个工具不足以满足所有的数据处理和存储需求，总体工作将被拆分成一系列单个足以高效完成的任务，然后用应用代码将它们缝合起来。然后隐藏实现细节，提供服务的接口或者API。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<p><img src=\"/../Asset/DDIA_Chapter1/DDIA.png\"></p>\n<h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h2><p>系统在 困境（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。</p>\n<p>造成错误的原因叫做 故障（fault），能预料并应对故障的系统特性可称为 容错（fault-tolerant） 或 韧性（resilient）。</p>\n<p>注意 故障（fault） 不同于 失效（failure），故障 通常定义为系统的一部分状态偏离其标准，而 失效 则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因 故障 而导致 失效。</p>\n<h3 id=\"硬件故障\"><a href=\"#硬件故障\" class=\"headerlink\" title=\"硬件故障\"></a>硬件故障</h3><p>硬盘崩溃、内存出错、机房断电、有人拔错网线……</p>\n<p>硬盘的 平均无故障时间（MTTF, mean time to failure） 约为 10 到 50 年</p>\n<p>因此从数学期望上讲，在拥有 10000 个磁盘的存储集群上，平均每天会有 1 个磁盘出故障。</p>\n<p>为了减少硬件故障，可以增加单个硬件的冗余度，如组建RAID、双路电源和热插拔 CPU、电池和柴油发电机作为后备电源……</p>\n<p>如果在硬件冗余的基础上进一步引入软件容错机制，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。如果需要重启机器，单服务器系统就需要计划停机。而允许机器失效的系统则可以一次修复一个节点，无需整个系统停机。</p>\n<h3 id=\"软件故障\"><a href=\"#软件故障\" class=\"headerlink\" title=\"软件故障\"></a>软件故障</h3><p>通常认为硬件故障是随机的、相互独立的。而内部的 系统性错误 往往难以预料且跨节点相关，往往可能造成更多的 系统失效。</p>\n<p>导致软件故障的bug往往会潜伏很长的时间，直到被异常情况触发为止（如特定的错误输入）。这种往往是因为 软件对环境的假设在大多数情况下是正确的，极小数情况下假设不成立 导致的。</p>\n<h3 id=\"人为错误\"><a href=\"#人为错误\" class=\"headerlink\" title=\"人为错误\"></a>人为错误</h3><p>设计并构建了软件系统的工程师是人类，维持系统运行的运维也是人类。人类也不可靠。运维配置错误是导致服务中断的首要原因。</p>\n<p>最好的系统会组合使用以下几种办法：</p>\n<ul>\n<li><p>以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API 和管理后台使做对事情更容易，搞砸事情更困难。</p>\n</li>\n<li><p>将人们最容易犯错的地方与可能导致失效的地方 解耦（decouple）。特别是提供一个功能齐全的非生产环境 沙箱（sandbox），使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。</p>\n</li>\n<li><p>在各个层次进行彻底的测试，从单元测试、全系统集成测试到手动测试。自动化测试易于理解，已经被广泛使用，特别适合用来覆盖正常情况中少见的 边缘场景（corner case）。</p>\n</li>\n<li><p>允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。 例如，快速回滚配置变更，分批发布新代码（以便任何意外错误只影响一小部分用户），并提供数据重算工具（以备旧的计算出错）。</p>\n</li>\n<li><p>配置详细和明确的监控，比如性能指标和错误率。 在其他工程学科中这指的是 遥测（telemetry）（一旦火箭离开了地面，遥测技术对于跟踪发生的事情和理解失败是至关重要的）。监控可以向我们发出预警信号，并允许我们检查是否有任何地方违反了假设和约束。当出现问题时，指标数据对于问题诊断是非常宝贵的。</p>\n</li>\n<li><p>良好的管理实践与充分的培训 —— 一个复杂而重要的方面，但超出了本书的范围。</p>\n</li>\n</ul>\n<h2 id=\"可伸缩性\"><a href=\"#可伸缩性\" class=\"headerlink\" title=\"可伸缩性\"></a>可伸缩性</h2><p>有合理的办法应对系统的增长（数据量、流量、复杂性）。讨论可伸缩性意味着考虑诸如 “如果系统以特定方式增长，有什么选项可以应对增长？” 和 “如何增加计算资源来处理额外的负载？” 等问题。</p>\n<h3 id=\"描述负载\"><a href=\"#描述负载\" class=\"headerlink\" title=\"描述负载\"></a>描述负载</h3><p>负载可以用一些称为 负载参数（load parameters） 的数字来描述。它可能是每秒向 Web 服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。</p>\n<h3 id=\"描述性能\"><a href=\"#描述性能\" class=\"headerlink\" title=\"描述性能\"></a>描述性能</h3><p>一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：</p>\n<ol>\n<li><p>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？</p>\n</li>\n<li><p>增加负载参数并希望保持性能不变时，需要增加多少系统资源？</p>\n</li>\n</ol>\n<h3 id=\"应对负载的方法\"><a href=\"#应对负载的方法\" class=\"headerlink\" title=\"应对负载的方法\"></a>应对负载的方法</h3><p>当负载参数增加时，如何保持良好的性能？</p>\n<p>适应某个级别负载的架构不太可能应付 10 倍于此的负载。如果你正在开发一个快速增长的服务，那么每次负载发生数量级的增长时，你可能都需要重新考虑架构 —— 或者更频繁。</p>\n<p>纵向伸缩（scaling up，也称为垂直伸缩，即 vertical scaling，转向更强大的机器）</p>\n<p>横向伸缩（scaling out，也称为水平伸缩，即 horizontal scaling，将负载分布到多台小机器上）</p>\n<p>有些系统是 弹性（elastic） 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动伸缩（人工分析容量并决定向系统添加更多的机器）。如果负载 极难预测（highly unpredictable），则弹性系统可能很有用，但手动伸缩系统更简单，并且意外操作可能会更少</p>\n<p>跨多台机器部署 无状态服务（stateless services） 非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。</p>\n<h2 id=\"可维护性\"><a href=\"#可维护性\" class=\"headerlink\" title=\"可维护性\"></a>可维护性</h2><p>许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。</p>\n<h3 id=\"可操作性，人生苦短，关爱运维\"><a href=\"#可操作性，人生苦短，关爱运维\" class=\"headerlink\" title=\"可操作性，人生苦短，关爱运维\"></a>可操作性，人生苦短，关爱运维</h3><p>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。</p>\n<h3 id=\"简单性，管理复杂度\"><a href=\"#简单性，管理复杂度\" class=\"headerlink\" title=\"简单性，管理复杂度\"></a>简单性，管理复杂度</h3><p>小型软件项目可以使用简单讨喜的、富表现力的代码，但随着项目越来越大，代码往往变得非常复杂，难以理解。这种复杂度拖慢了所有系统相关人员，进一步增加了维护成本。一个陷入复杂泥潭的软件项目有时被描述为 烂泥潭</p>\n<p>简化系统并不一定意味着减少功能；它也可以意味着消除 额外的（accidental） 的复杂度。用于消除 额外复杂度 的最好工具之一是 抽象（abstraction）。</p>\n<h3 id=\"可演化性，拥抱变化\"><a href=\"#可演化性，拥抱变化\" class=\"headerlink\" title=\"可演化性，拥抱变化\"></a>可演化性，拥抱变化</h3><p>在组织流程方面， 敏捷（agile） 工作模式为适应变化提供了一个框架。敏捷社区还开发了对在频繁变化的环境中开发软件很有帮助的技术工具和模式，如 测试驱动开发（TDD, test-driven development） 和 重构（refactoring） 。</p>\n","categories":[{"name":"分布式","slug":"分布式","count":3,"path":"api/categories/分布式.json"},{"name":"DDIA","slug":"分布式/DDIA","count":3,"path":"api/categories/分布式/DDIA.json"}],"tags":[{"name":"分布式","slug":"分布式","count":3,"path":"api/tags/分布式.json"},{"name":"DDIA","slug":"DDIA","count":3,"path":"api/tags/DDIA.json"}]}