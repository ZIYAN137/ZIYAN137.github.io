{"title":"rcore-camp-2025S-stage2-lab3","slug":"rcore-camp-2025S-stage2-lab3","date":"2025-04-30T09:02:13.000Z","updated":"2025-05-05T04:30:44.384Z","comments":true,"path":"api/articles/rcore-camp-2025S-stage2-lab3.json","photos":[],"excerpt":null,"covers":null,"content":"<h1 id=\"编程作业\"><a href=\"#编程作业\" class=\"headerlink\" title=\"编程作业\"></a>编程作业</h1><h2 id=\"1-迁移\"><a href=\"#1-迁移\" class=\"headerlink\" title=\"1. 迁移\"></a>1. 迁移</h2><p>之前的 <code>TaskManager</code> 被拆分到 <code>manager.rs</code> 和 <code>processor.rs</code> 中，<br>把之前的代码都迁移到 <code>processor.rs</code> 中即可。</p>\n<h2 id=\"2-Spawn\"><a href=\"#2-Spawn\" class=\"headerlink\" title=\"2. Spawn\"></a>2. Spawn</h2><p>从 <code>fork</code> 和 <code>exec</code> 中各偷一点缝合起来就行了</p>\n<h2 id=\"3-Stride\"><a href=\"#3-Stride\" class=\"headerlink\" title=\"3. Stride\"></a>3. Stride</h2><ol>\n<li>首先，为 <code>TaskControlBlockInner</code> 添加 <code>stride</code> 和 <code>priority</code> 字段。</li>\n<li>将 <code>TaskManager</code> 中存放TCB的数据结构改为 <code>BinaryHeap</code> 详见<a href=\"https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html\">BinaryHeap</a></li>\n<li>为 <code>TaskControlBlock</code> 实现以下trait:<ul>\n<li><code>Ord</code></li>\n<li><code>PartialOrd</code></li>\n<li>‘Eq’</li>\n<li>‘PartialEq’</li>\n</ul>\n</li>\n<li>修改 <code>run_tasks()</code> ，使得进程运行完后，可以增加它的stride</li>\n</ol>\n<h1 id=\"简答作业\"><a href=\"#简答作业\" class=\"headerlink\" title=\"简答作业\"></a>简答作业</h1><p>stride 算法深入</p>\n<p>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 pass = 10 的进程，使用 8bit 无符号整形储存 stride， p1.stride = 255, p2.stride = 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</p>\n<h2 id=\"Q1-实际情况是轮到-p1-执行吗？为什么？\"><a href=\"#Q1-实际情况是轮到-p1-执行吗？为什么？\" class=\"headerlink\" title=\"Q1.实际情况是轮到 p1 执行吗？为什么？\"></a>Q1.实际情况是轮到 p1 执行吗？为什么？</h2><p>不是，应该轮到P2执行，因为P2溢出回环后会比P1小</p>\n<blockquote>\n<p>我们之前要求进程优先级 &gt;= 2 其实就是为了解决这个问题。可以证明， 在不考虑溢出的情况下 , 在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX – STRIDE_MIN &lt;= BigStride / 2。</p>\n</blockquote>\n<h2 id=\"Q2-为什么？尝试简单说明（不要求严格证明）。\"><a href=\"#Q2-为什么？尝试简单说明（不要求严格证明）。\" class=\"headerlink\" title=\"Q2.为什么？尝试简单说明（不要求严格证明）。\"></a>Q2.为什么？尝试简单说明（不要求严格证明）。</h2><p>在 stride 算法中，保证进程的优先级大于等于 2 可以避免 stride 值过小或溢出问题。<br>通过控制进程间的优先级差距，确保 STRIDE_MAX - STRIDE_MIN ≤ BigStride / 2，<br>即最大 stride 和最小 stride 之间的差异不超过最大 stride 的一半，<br>这样可以防止过大的优先级差导致调度不公平，从而保持系统的公平性和稳定性。</p>\n<h2 id=\"Q3-已知以上结论，考虑溢出的情况下，可以为-Stride-设计特别的比较器，让-BinaryHeap-的-pop-方法能返回真正最小的-Stride。补全下列代码中的-partial-cmp-函数，假设两个-Stride-永远不会相等。\"><a href=\"#Q3-已知以上结论，考虑溢出的情况下，可以为-Stride-设计特别的比较器，让-BinaryHeap-的-pop-方法能返回真正最小的-Stride。补全下列代码中的-partial-cmp-函数，假设两个-Stride-永远不会相等。\" class=\"headerlink\" title=\"Q3.已知以上结论，考虑溢出的情况下，可以为 Stride 设计特别的比较器，让 BinaryHeap 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 partial_cmp 函数，假设两个 Stride 永远不会相等。\"></a>Q3.已知以上结论，考虑溢出的情况下，可以为 Stride 设计特别的比较器，让 BinaryHeap<stride> 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 partial_cmp 函数，假设两个 Stride 永远不会相等。</stride></h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> core::cmp::Ordering;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Stride</span>(<span class=\"type\">u64</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">PartialOrd</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Stride</span> {</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">partial_cmp</span>(&amp;<span class=\"keyword\">self</span>, other: &amp;<span class=\"keyword\">Self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;Ordering&gt; {</span><br><span class=\"line\">       <span class=\"keyword\">let</span> <span class=\"variable\">self_stride</span> = <span class=\"keyword\">self</span>.<span class=\"number\">0</span> &amp; <span class=\"number\">255</span>;  <span class=\"comment\">// 保证 stride 在 0 到 255 之间</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> <span class=\"variable\">other_stride</span> = other.<span class=\"number\">0</span> &amp; <span class=\"number\">255</span>; <span class=\"comment\">// 保证 stride 在 0 到 255 之间</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> self_stride &lt; other_stride {</span><br><span class=\"line\">          <span class=\"title function_ invoke__\">Some</span>(Ordering::Less)</span><br><span class=\"line\">       } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> self_stride &gt; other_stride {</span><br><span class=\"line\">          <span class=\"title function_ invoke__\">Some</span>(Ordering::Greater)</span><br><span class=\"line\">       } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          <span class=\"title function_ invoke__\">Some</span>(Ordering::Equal)</span><br><span class=\"line\">       }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">PartialEq</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Stride</span> {</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">eq</span>(&amp;<span class=\"keyword\">self</span>, other: &amp;<span class=\"keyword\">Self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">bool</span> {</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>TIPS: 使用 8 bits 存储 stride, BigStride = 255, 则: (125 &lt; 255) == false, (129 &lt; 255) == true.</p>\n<h1 id=\"荣誉准则\"><a href=\"#荣誉准则\" class=\"headerlink\" title=\"荣誉准则\"></a>荣誉准则</h1><ol>\n<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：</p>\n<p>无</p>\n</li>\n<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>\n<p>无</p>\n</li>\n<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>\n</li>\n<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>\n</li>\n</ol>\n","categories":[],"tags":[{"name":"Rcore","slug":"Rcore","count":6,"path":"api/tags/Rcore.json"}]}