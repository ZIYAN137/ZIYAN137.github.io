{"title":"DDIA-Chapter2","slug":"DDIA-Chapter2","date":"2025-04-22T13:18:52.000Z","updated":"2025-05-05T04:30:44.384Z","comments":true,"path":"api/articles/DDIA-Chapter2.json","photos":[],"excerpt":"第二章：数据模型与查询语言在分布式系统和数据库设计中，数据模型和查询语言的选择至关重要。它们不仅影响数据的存储方式，还直接决定了数据的查询效率和灵活性。本篇博客将深入探讨不同的数据模型，包括传统的关系模型、现代的文档模型以及图数据模型，并比较它们在实际应用中的表现与优势。此外，我们还将讨论查询语言的不同类型，分析声明式与命令式语言的优缺点，帮助你更好地理解和选择适合自己需求的数据模型和查询方式。","covers":["/../Asset/DDIA-Chapter2/DDIA.png","/images/image-3.png"],"content":"<h1 id=\"第二章：数据模型与查询语言\"><a href=\"#第二章：数据模型与查询语言\" class=\"headerlink\" title=\"第二章：数据模型与查询语言\"></a>第二章：数据模型与查询语言</h1><p>在分布式系统和数据库设计中，数据模型和查询语言的选择至关重要。它们不仅影响数据的存储方式，还直接决定了数据的查询效率和灵活性。本篇博客将深入探讨不同的数据模型，包括传统的关系模型、现代的文档模型以及图数据模型，并比较它们在实际应用中的表现与优势。此外，我们还将讨论查询语言的不同类型，分析声明式与命令式语言的优缺点，帮助你更好地理解和选择适合自己需求的数据模型和查询方式。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/../Asset/DDIA-Chapter2/DDIA.png\"></p>\n<p>如何分析一个数据模型：</p>\n<ol>\n<li><p>基本考察点：数据基本元素，和元素之间的对应关系</p>\n</li>\n<li><p>利用几种常用模型来比较：（最为流行的）关系模型，（树状的文档模型），（极大自由度的）图模型</p>\n</li>\n<li><p>schema模式：强schema（写时约束）；弱schema（读时解析）</p>\n</li>\n</ol>\n<p>如何考量查询语言：</p>\n<ol>\n<li><p>如何与数据模型关联、匹配</p>\n</li>\n<li><p>声明式（declarative）和命令式（imperative）</p>\n</li>\n</ol>\n<h2 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h2><p>如何组织数据，如何标准化关系，如何关联现实</p>\n<p>它既决定了实现，也左右了认知</p>\n<p><img src=\"/images/image-3.png\"></p>\n<p>每层模型核心问题：如何用下一层的接口来对本层进行建模？</p>\n<ol>\n<li><p>作为应用开发者， 你将现实中的具体问题抽象为一组对象、数据结构（data structure） 以及作用于其上的 API。</p>\n</li>\n<li><p>作为数据库管理员（DBA），为了持久化上述数据结构，你需要将他们表达为通用的数据模型（data model），如文档数据库中的 XML/JSON、关系数据库中的表、图数据库中的图。</p>\n</li>\n<li><p>作为数据库系统开发者，你需要将上述数据模型组织为内存中、硬盘中或者网络中的字节（Bytes） 流，并提供多种操作数据集合的方法。</p>\n</li>\n<li><p>作为硬件工程师，你需要将字节流表示为二极管的电位（内存）、磁场中的磁极（磁盘）、光纤中的光信号（网络）。</p>\n</li>\n</ol>\n<p>这也反过来说明了，好的数据模型需有两个特点：</p>\n<ol>\n<li><p>简洁直观</p>\n</li>\n<li><p>具有组合性</p>\n</li>\n</ol>\n<h2 id=\"关系模型\"><a href=\"#关系模型\" class=\"headerlink\" title=\"关系模型\"></a>关系模型</h2><p>特点如下：</p>\n<ol>\n<li><p>将数据以关系呈现给用户（比如：一组包含行列的二维表）。</p>\n</li>\n<li><p>提供操作数据集合的关系算子。</p>\n</li>\n</ol>\n<p>常见分类</p>\n<ol>\n<li><p>事务型（TP）：银行交易、火车票</p>\n</li>\n<li><p>分析型（AP）：数据报表、监控表盘</p>\n</li>\n<li><p>混合型（HTAP）</p>\n</li>\n</ol>\n<h3 id=\"NoSQL的诞生\"><a href=\"#NoSQL的诞生\" class=\"headerlink\" title=\"NoSQL的诞生\"></a>NoSQL的诞生</h3><p>NoSQL试图像网状模型、层次模型一样，试图推翻关系模型的统治地位。虽然它没有涉及任何特定的技术，但是迅速在网络社区中散播开来，NoSQL 被追溯性地重新解释为 不仅是 SQL（Not Only SQL）</p>\n<p>采用 NoSQL 数据库的背后有几个驱动因素，其中包括：</p>\n<ul>\n<li><p>需要比关系数据库更好的可伸缩性，包括非常大的数据集或非常高的写入吞吐量</p>\n</li>\n<li><p>相比商业数据库产品，免费和开源软件更受偏爱</p>\n</li>\n<li><p>关系模型不能很好地支持一些特殊的查询操作</p>\n</li>\n<li><p>受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型</p>\n</li>\n</ul>\n<h2 id=\"文档模型\"><a href=\"#文档模型\" class=\"headerlink\" title=\"文档模型\"></a>文档模型</h2><h3 id=\"面向对象和关系模型的不匹配\"><a href=\"#面向对象和关系模型的不匹配\" class=\"headerlink\" title=\"面向对象和关系模型的不匹配\"></a>面向对象和关系模型的不匹配</h3><p>目前大多数程序的开发都使用了面向对象的编程范式进行开发，这导致了对SQL数据模型的不匹配：如果数据要存在关系表中，就需要一个转换层。对象关系映射（ORM）可以减少转换层的代码数量，但是也不能完全隐藏二者之间的差异。</p>\n<p>简而言之，关系模型很难直观的表示一对多的关系。比如简历上，一个人可能有多段教育经历和多段工作经历。</p>\n<p>文档模型：使用Json和XML的天然嵌套</p>\n<p>关系模型：使用SQL模型将职位，教育单独整一张表，然后再用户表中使用外键关联</p>\n<p>在简历这个例子中，文档模型还有几个优势</p>\n<ol>\n<li><p>模式灵活</p>\n</li>\n<li><p>更好的局部性</p>\n</li>\n<li><p>结构表达语义</p>\n</li>\n</ol>\n<h3 id=\"多对一和多对多\"><a href=\"#多对一和多对多\" class=\"headerlink\" title=\"多对一和多对多\"></a>多对一和多对多</h3><p>对比各种数据模型的切入角度</p>\n<p>region 在存储时，为什么不直接存储纯字符串：“Greater Seattle Area”，而是先存为 region_id -&gt;region name，其他地方都引用 region_id？</p>\n<ol>\n<li><p>统一样式：所有用到相同概念的地方都有相同的拼写和样式</p>\n</li>\n<li><p>避免歧义：可能有同名地区</p>\n</li>\n<li><p>易于修改：如果一个地区改名了，我们不用去逐一修改所有引用他的地方</p>\n</li>\n<li><p>本地化支持：如果翻译成其他语言，可以只翻译名字表。</p>\n</li>\n<li><p>更好搜索：列表可以关联地区，进行树形组织</p>\n</li>\n</ol>\n<p>类似于面向抽象编程而非面向细节编程，ID 对人类是无意义的，无意义的意味着不会随着现实世界的将来的改变而改动。</p>\n<p>这在关系数据库表设计时需要考虑，即如何控制冗余（duplication）。会有几种范式（normalization） 来消除冗余。</p>\n<p>文档型数据库很擅长处理一对多的树形关系，却不擅长处理多对多的图形关系。如果其不支持 Join，则处理多对多关系的复杂度就从数据库侧移动到了应用侧。</p>\n<p>文档vs关系</p>\n<ol>\n<li><p>对于一对多关系，文档型数据库将嵌套数据放在父节点中，而非单拎出来放另外一张表。</p>\n</li>\n<li><p>对于多对一和多对多关系，本质上，两者都是使用外键（文档引用）进行索引。查询时需要进行 join 或者动态跟随。</p>\n</li>\n</ol>\n<h3 id=\"文档模型是否在重复历史\"><a href=\"#文档模型是否在重复历史\" class=\"headerlink\" title=\"文档模型是否在重复历史\"></a>文档模型是否在重复历史</h3><h4 id=\"层次模型\"><a href=\"#层次模型\" class=\"headerlink\" title=\"层次模型\"></a>层次模型</h4><ol>\n<li><p>树形组织，每个子节点只允许有一个父节点</p>\n</li>\n<li><p>节点存储数据，节点有类型</p>\n</li>\n<li><p>节点间使用类似指针方式连接</p>\n</li>\n</ol>\n<p>它跟文档模型很像，也因此很难解决多对多的关系，并且不支持 Join。</p>\n<p>为了解决它的局限性，人们提出了各种解决方案，最突出的是关系模型和网状模型</p>\n<h4 id=\"网状模型\"><a href=\"#网状模型\" class=\"headerlink\" title=\"网状模型\"></a>网状模型</h4><p>允许一个节点有多个父节点。</p>\n<p>多对一和多对多都可以由路径来表示。访问记录的唯一方式是顺着元素和链接组成的链路进行访问，这个链路叫访问路径 （access path）。难度犹如在 n-维空间中进行导航。</p>\n<p>内存有限，因此需要严格控制遍历路径。并且需要事先知道数据库的拓扑结构，针对不同应用写大量的专用代码。</p>\n<h4 id=\"关系模型-1\"><a href=\"#关系模型-1\" class=\"headerlink\" title=\"关系模型\"></a>关系模型</h4><p>在关系模型中，数据被组织成元组（tuples），进而集合成关系（relations）；在 SQL 中分别对应行（rows）和表（tables）。</p>\n<p>其主要目的和贡献在于提供了一种声明式的描述数据和构建查询的方法。</p>\n<h3 id=\"文档型-vs-关系型\"><a href=\"#文档型-vs-关系型\" class=\"headerlink\" title=\"文档型 vs 关系型\"></a>文档型 vs 关系型</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>文档型</th>\n<th>关系型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对应关系</td>\n<td>数据有天然的一对多、树形嵌套关系，如图形。</td>\n<td>通过外键 + Join 可以处理多对一、多对多关系</td>\n</tr>\n<tr>\n<td>代码简化</td>\n<td>数据具有文档结构，则文档模型天然合适，用关系型会使得建模繁琐、访问复杂。</td>\n<td>主键，索引，条件过滤</td>\n</tr>\n<tr>\n<td>Join 支持</td>\n<td>对 Join 支持的不太好</td>\n<td>支持的还可以，但 Join 的实现会有很多难点</td>\n</tr>\n<tr>\n<td>模式灵活性</td>\n<td>弱 schema，支持动态增加字段</td>\n<td>强 schema，修改 schema 代价很大</td>\n</tr>\n<tr>\n<td>访问局部性</td>\n<td>1. 一次性访问整个文档，较优  2. 只访问文档一部分，较差</td>\n<td>分散在多个表中</td>\n</tr>\n</tbody></table>\n<h3 id=\"文档模型中-Schema-的灵活性\"><a href=\"#文档模型中-Schema-的灵活性\" class=\"headerlink\" title=\"文档模型中 Schema 的灵活性\"></a>文档模型中 Schema 的灵活性</h3><p>文档型数据库是 schemaless 不太准确，更贴切的应该是 schema-on-read。</p>\n<table>\n<thead>\n<tr>\n<th>数据模型</th>\n<th></th>\n<th>编程语言</th>\n<th></th>\n<th>性能 &amp; 空间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>schema-on-read</td>\n<td>写入时不校验，而在读取时进行动态解析。</td>\n<td>弱类型</td>\n<td>动态，在运行时解析</td>\n<td>读取时动态解析，性能较差。写入时无法确定类型，无法对齐，空间利用率较差。</td>\n</tr>\n<tr>\n<td>schema-on-write</td>\n<td>写入时校验，数据对齐到schema。</td>\n<td>强类型</td>\n<td>静态，编译时确定</td>\n<td>性能和空间使用都较优。</td>\n</tr>\n</tbody></table>\n<p>文档型数据库使用场景特点：</p>\n<ul>\n<li><p>有多种类型的数据，但每个放一张表又不合适。</p>\n</li>\n<li><p>数据类型和结构由外部决定，你没办法控制数据的变化。</p>\n</li>\n</ul>\n<h2 id=\"数据查询语言\"><a href=\"#数据查询语言\" class=\"headerlink\" title=\"数据查询语言\"></a>数据查询语言</h2><p>获取动物表中所有鲨鱼类动物。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 声明式，比如SQL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> animals <span class=\"keyword\">WHERE</span> family <span class=\"operator\">=</span> <span class=\"string\">'Sharks'</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式，比如JavaScript XML</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSharks</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sharks = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; animals.<span class=\"property\">length</span>; i++) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (animals[i].<span class=\"property\">family</span> === <span class=\"string\">'Sharks'</span>) {</span><br><span class=\"line\">      sharks.<span class=\"title function_\">push</span>(animals[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sharks;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明式vs命令式\"><a href=\"#声明式vs命令式\" class=\"headerlink\" title=\"声明式vs命令式\"></a>声明式vs命令式</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>声明式 (declarative) 语言</th>\n<th>命令式 (imperative) 语言</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>概念</td>\n<td>描述控制流程而非执行流程的过程</td>\n<td>描述命令的执行过程，用一系列语句来不断改变状态</td>\n</tr>\n<tr>\n<td>举例</td>\n<td>SQL, CSS, XSL</td>\n<td>IMS, CODASYL, 通用语言如 C, C++, JS</td>\n</tr>\n<tr>\n<td>抽象程度</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>解耦程度</td>\n<td>与实现解耦。可以持续优化查询引擎性能；</td>\n<td>与实现解耦较深。</td>\n</tr>\n<tr>\n<td>解耦执行</td>\n<td>语法分析 -&gt;语法分析 -&gt;语义分析 -&gt;生成执行计划 -&gt;执行计划优化</td>\n<td>语法分析 -&gt;语义分析 -&gt;中间代码生成 -&gt;代码优化 -&gt;目标代码生成</td>\n</tr>\n<tr>\n<td>多核并行</td>\n<td>声明式更具多核潜力，给予更多运行时优化空间</td>\n<td>命令式由于指定了代码执行顺序，编译时优化空间较小。</td>\n</tr>\n</tbody></table>\n<p>Q：相对声明式语言，命令式语言有什么优点？</p>\n<ol>\n<li><p>当描述的目标变得复杂时，声明式表达能力不够。</p>\n</li>\n<li><p>实现命令式的语言往往不会和声明式那么泾渭分明，通过合理抽象，通过一些编程范式（函数式），可以让代码兼顾表达力和清晰性。</p>\n</li>\n</ol>\n<h3 id=\"数据库之外：WEB中的声明式\"><a href=\"#数据库之外：WEB中的声明式\" class=\"headerlink\" title=\"数据库之外：WEB中的声明式\"></a>数据库之外：WEB中的声明式</h3><p>声明式查询语言的优势不仅限于数据库。为了说明这一点，让我们在一个完全不同的环境中比较声明式和命令式方法：一个 Web 浏览器。</p>\n<p>假设你有一个关于海洋动物的网站。用户当前正在查看鲨鱼页面，因此你将当前所选的导航项目 “鲨鱼” 标记为当前选中项目。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">\"selected\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Sharks<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Great White Shark<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Tiger Shark<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Hammerhead Shark<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Whales<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Blue Whale<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Humpback Whale<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Fin Whale<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果使用 CSS，则只需（CSS selector）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-class\">.selected</span> &gt; <span class=\"selector-tag\">p</span> {</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>如果使用 XSL，则只需（XPath selector）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsl:template</span> <span class=\"attr\">match</span>=<span class=\"string\">\"li[@class='selected']/p\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fo:block</span> <span class=\"attr\">background-color</span>=<span class=\"string\">\"blue\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">xsl:apply-templates</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fo:block</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xsl:template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果使用 JavaScript（而不借助上述 selector 库）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> liElements = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; liElements.<span class=\"property\">length</span>; i++) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (liElements[i].<span class=\"property\">className</span> === <span class=\"string\">'selected'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> children = liElements[i].<span class=\"property\">childNodes</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; children.<span class=\"property\">length</span>; j++) {</span><br><span class=\"line\">      <span class=\"keyword\">var</span> child = children[j];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child.<span class=\"property\">nodeType</span> === <span class=\"title class_\">Node</span>.<span class=\"property\">ELEMENT_NODE</span> &amp;&amp; child.<span class=\"property\">tagName</span> === <span class=\"string\">'P'</span>) {</span><br><span class=\"line\">        child.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">'style'</span>, <span class=\"string\">'background-color: blue'</span>);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MapReduce查询\"><a href=\"#MapReduce查询\" class=\"headerlink\" title=\"MapReduce查询\"></a>MapReduce查询</h3><p>MapReduce 是一种介于</p>\n<ul>\n<li><p>声明式：用户不必显式定义数据集的遍历方式、shuffle 过程等执行过程。</p>\n</li>\n<li><p>命令式：用户又需要定义针对单条数据的执行过程。</p>\n</li>\n</ul>\n<p>两者间的混合数据模型。</p>\n<p><strong>Google的MapReduce框架</strong></p>\n<ol>\n<li><p>借鉴自函数式编程。</p>\n</li>\n<li><p>一种相当简单的编程模型，或者说原子的抽象，现在不太够用。</p>\n</li>\n<li><p>但在大数据处理工具匮乏的蛮荒时代（03 年以前），谷歌提出的这套框架相当有开创性。</p>\n</li>\n</ol>\n<p><a href=\"images/image.png\"></a></p>\n<p>一些 NoSQL 数据存储（包括 MongoDB 和 CouchDB）支持有限形式的 MapReduce，作为在多个文档中执行只读查询的机制。</p>\n<p>关于 MapReduce 更详细的介绍在 第十章。现在我们只简要讨论一下 MongoDB 使用的模型。</p>\n<p>MapReduce 一些特点：</p>\n<ol>\n<li><p>要求 Map 和 Reduce 是纯函数。即无任何副作用，在任意地点、以任意次序执行任何多次，对相同的输入都能得到相同的输出。因此容易并发调度。</p>\n</li>\n<li><p>非常底层、但表达力强大的编程模型。可基于其实现 SQL 等高级查询语言，如 Hive。</p>\n</li>\n</ol>\n<p>但要注意：</p>\n<ol>\n<li><p>不是所有的分布式 SQL 都基于 MapReduce 实现。</p>\n</li>\n<li><p>不是只有 MapReduce 才允许嵌入通用语言（如 js）模块。</p>\n</li>\n<li><p>MapReduce 是有一定理解成本的，需要非常熟悉其执行原理才能让两个函数紧密配合。</p>\n</li>\n</ol>\n<p>假设你是一名海洋生物学家，每当你看到海洋中的动物时，你都会在数据库中添加一条观察记录。现在你想生成一个报告，说明你每月看到多少鲨鱼。</p>\n<p>MongoDB：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.<span class=\"property\">observations</span>.<span class=\"title function_\">mapReduce</span>(</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">map</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 2. 对所有符合条件 doc 执行 map</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> year = <span class=\"variable language_\">this</span>.<span class=\"property\">observationTimestamp</span>.<span class=\"title function_\">getFullYear</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> month = <span class=\"variable language_\">this</span>.<span class=\"property\">observationTimestamp</span>.<span class=\"title function_\">getMonth</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"title function_\">emit</span>(year + <span class=\"string\">'-'</span> + month, <span class=\"variable language_\">this</span>.<span class=\"property\">numAnimals</span>); <span class=\"comment\">// 3. 输出一个 kv pair</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">reduce</span>(<span class=\"params\">key, values</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 4. 按 key 聚集</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">sum</span>(values); <span class=\"comment\">// 5. 相同 key 加和</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">  {</span><br><span class=\"line\">    <span class=\"attr\">query</span>: { <span class=\"attr\">family</span>: <span class=\"string\">'Sharks'</span> }, <span class=\"comment\">// 1. 筛选</span></span><br><span class=\"line\">    <span class=\"attr\">out</span>: <span class=\"string\">'monthlySharkReport'</span>, <span class=\"comment\">// 6. reduce 结果集</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上述语句在执行时，经历了：筛选（filter） -&gt; 遍历并执行 map -&gt; 对输出按 key 聚集（shuffle）-&gt; 对聚集的数据逐一 reduce -&gt; 输出结果集。</p>\n<p>MapReduce 的一个可用性问题是，必须编写两个密切合作的 JavaScript 函数，这通常比编写单个查询更困难。此外，声明式查询语言为查询优化器提供了更多机会来提高查询的性能。基于这些原因，MongoDB 2.2 添加了一种叫做 聚合管道 的声明式查询语言的支持。用这种语言表述鲨鱼计数查询如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.<span class=\"property\">observations</span>.<span class=\"title function_\">aggregate</span>([{ <span class=\"attr\">$match</span>: { <span class=\"attr\">family</span>: <span class=\"string\">\"Sharks\"</span> } },{ <span class=\"attr\">$group</span>: {</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: {</span><br><span class=\"line\">      <span class=\"attr\">year</span>:  { <span class=\"attr\">$year</span>:  <span class=\"string\">\"$observationTimestamp\"</span> },</span><br><span class=\"line\">      <span class=\"attr\">month</span>: { <span class=\"attr\">$month</span>: <span class=\"string\">\"$observationTimestamp\"</span> }},</span><br><span class=\"line\">    <span class=\"attr\">totalAnimals</span>: { <span class=\"attr\">$sum</span>: <span class=\"string\">\"$numAnimals\"</span> } }}]);</span><br></pre></td></tr></table></figure>\n\n<p>聚合管道语言的表现力与 SQL 子集相当，但是它使用基于 JSON 的语法而不是 SQL 那种接近英文句式的语法；这种差异也许只是口味问题。这个故事的寓意是：NoSQL 系统可能会意外发现自己只是重新发明了一套经过乔装改扮的 SQL。</p>\n<h2 id=\"图模型\"><a href=\"#图模型\" class=\"headerlink\" title=\"图模型\"></a>图模型</h2><ul>\n<li><p>文档模型的适用场景？ 你的建模场景中存在着大量一对多（one-to-many）的关系。</p>\n</li>\n<li><p>图模型的适用场景？ 你的建模场景中存在大量的多对多（many-to-many）的关系。</p>\n</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>图数据模型（属性图）的基本概念一般有三个：点，边和附着于两者之上的属性。</p>\n<p>常见的可以用图建模的场景：</p>\n<table>\n<thead>\n<tr>\n<th>示例</th>\n<th>模型</th>\n<th>应用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>社交图谱</td>\n<td>人是点，follow 关系是边</td>\n<td>六度分隔，信息流推荐</td>\n</tr>\n<tr>\n<td>互联网</td>\n<td>网页是点，链接关系是边</td>\n<td>PageRank</td>\n</tr>\n<tr>\n<td>路网</td>\n<td>交通枢纽是点，铁路/公路是边</td>\n<td>路径规划，导航最短路径</td>\n</tr>\n<tr>\n<td>洗钱</td>\n<td>账户是点，转账关系是边</td>\n<td>判断是否有环</td>\n</tr>\n<tr>\n<td>知识图谱</td>\n<td>概念是点，关联关系是边</td>\n<td>启发式问答</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>同构（homogeneous）数据和异构数据 图模型中的点变可以像关系中的表一样都具有相同类型；但是，一张图中的点和变也可以具有不同类型，能够容纳异构数据是图模型善于处理多对多关系的一大原因。</p>\n</blockquote>\n<p>本节都会以下图为例，它表示了一对夫妇，来自美国爱达荷州的 Lucy 和来自法国 的 Alain：他们已婚，住在伦敦。</p>\n<p><a href=\"images/image-1.png\"></a></p>\n<p>有几种不同但相关的方法用来构建和查询图表中的数据。</p>\n<ol>\n<li><p>属性图（property graph）：比较主流，如 Neo4j、Titan、InfiniteGraph</p>\n</li>\n<li><p>三元组（triple-store）：如 Datomic、AllegroGraph</p>\n</li>\n</ol>\n<p>还将看到图的三种声明式查询语言：Cypher，SPARQL 和 Datalog。</p>\n<h3 id=\"属性图\"><a href=\"#属性图\" class=\"headerlink\" title=\"属性图\"></a>属性图</h3><table>\n<thead>\n<tr>\n<th><strong>点 (vertices, nodes, entities)</strong></th>\n<th><strong>边 (edges, relations, arcs)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>全局唯一 ID</td>\n<td>全局唯一 ID</td>\n</tr>\n<tr>\n<td>出边集合</td>\n<td>起始点</td>\n</tr>\n<tr>\n<td>入边集合</td>\n<td>终止点</td>\n</tr>\n<tr>\n<td>属性集 (kv 对表示)</td>\n<td>属性集 (kv 对表示)</td>\n</tr>\n<tr>\n<td>表示点类型的 type?</td>\n<td>表示边类型的 label</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>属性图具体实现时也可以分为强类型和弱类型，NebulaGraph 是强类型，好处在于效率高，但灵活性差；Neo4j 是弱类型。书中应该是用的弱类型，此时每个点都是一组属性集，不需要 type。</p>\n</blockquote>\n<p>可以使用我们熟悉的 SQL 语义来构建一个图模型</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 点表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> vertices (</span><br><span class=\"line\">    vertex_id <span class=\"type\">integer</span> PRIMARYKEY, properties json</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 边表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> edges (</span><br><span class=\"line\">    edge_id <span class=\"type\">integer</span> <span class=\"keyword\">PRIMARY KEY</span>,</span><br><span class=\"line\">    tail_vertex <span class=\"type\">integer</span> <span class=\"keyword\">REFERENCES</span> vertices (vertex_id),</span><br><span class=\"line\">    head_vertex <span class=\"type\">integer</span> <span class=\"keyword\">REFERENCES</span> vertices (vertex_id),</span><br><span class=\"line\">    label text,</span><br><span class=\"line\">    properties json</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 对点的反向索引，图遍历时用。给定点，找出点的所有入边和出边。</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX edges_tails <span class=\"keyword\">ON</span> edges (tail_vertex);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX edges_heads <span class=\"keyword\">ON</span> edges (head_vertex);</span><br></pre></td></tr></table></figure>\n\n<p>图是一种很灵活的建模方式：</p>\n<ol>\n<li><p>任何两点间都可以插入边，没有任何模式限制。</p>\n</li>\n<li><p>对于任何顶点都可以高效找到其入边和出边，从而进行图遍历。</p>\n</li>\n<li><p>使用多种标签来标记不同类型边（关系）。</p>\n</li>\n</ol>\n<p>相对于关系型数据来说，可以在同一个图中保存异构类型的数据和关系，给了图极大的表达能力</p>\n<p>这种表达能力，根据图中的例子，包括：</p>\n<ol>\n<li><p>对同样的概念，可以用不同结构表示。如不同国家的行政划分。</p>\n</li>\n<li><p>对同样的概念，可以用不同粒度表示。比如 Lucy 的现居住地和诞生地。</p>\n</li>\n<li><p>可以很自然的进行演化。</p>\n</li>\n</ol>\n<p>将异构的数据容纳在一张图中，可以通过图遍历，轻松完成关系型数据库中需要多次 Join 的操作。</p>\n<h3 id=\"Cypher查询语言\"><a href=\"#Cypher查询语言\" class=\"headerlink\" title=\"Cypher查询语言\"></a>Cypher查询语言</h3><p>Cypher 是 Neo4j 创造的一种查询语言。（此处的Cypher与网络安全无关，而是来自电影黑客帝国）</p>\n<p>fig2-5中的模型通过 Cypher 查询的例子：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE</span><br><span class=\"line\">  (NAmerica:Location {name:'North America', type:'continent'}),</span><br><span class=\"line\">  (USA:Location      {name:'United States', type:'country'  }),</span><br><span class=\"line\">  (Idaho:Location    {name:'Idaho',         type:'state'    }),</span><br><span class=\"line\">  (Lucy:Person       {name:'Lucy' }),</span><br><span class=\"line\">  (Idaho) -[:WITHIN]-&gt;  (USA)  -[:WITHIN]-&gt; (NAmerica),</span><br><span class=\"line\">  (Lucy)  -[:BORN_IN]-&gt; (Idaho)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要进行一个这样的查询：找出所有从美国移居到欧洲的人名。</p>\n<p>转化为图语言，即为：给定条件，BORN_IN 指向美国的地点，并且 LIVING_IN 指向欧洲的地点，找到所有符合上述条件的点，并且返回其名字属性。</p>\n<p>用 Cypher 语句可表示为：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MATCH</span><br><span class=\"line\">  (person) -[:BORN_IN]-&gt;  () -[:WITHIN*0..]-&gt; (us:Location {name:'United States'}),</span><br><span class=\"line\">  (person) -[:LIVES_IN]-&gt; () -[:WITHIN*0..]-&gt; (eu:Location {name:'Europe'})</span><br><span class=\"line\">RETURN person.name</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li><p><code>person</code> 顶点拥有一条到某个顶点的 <code>BORN_IN</code> 出边。从那个顶点开始，沿着一系列 <code>WITHIN</code> 出边最终到达一个类型为 <code>Location</code>，<code>name</code> 属性为 <code>United States</code> 的顶点。</p>\n</li>\n<li><p><code>person</code> 顶点还拥有一条 <code>LIVES_IN</code> 出边。沿着这条边，可以通过一系列 <code>WITHIN</code> 出边最终到达一个类型为 <code>Location</code>，<code>name</code> 属性为 <code>Europe</code> 的顶点。</p>\n</li>\n</ol>\n</blockquote>\n<p>注意到：</p>\n<ol>\n<li><p>点 <code>()</code>，边 <code>-[]→</code>，标签\\类型 <code>:</code>，属性 <code>{}</code>。</p>\n</li>\n<li><p>名字绑定或者说变量：<code>person</code></p>\n</li>\n<li><p>0 到多次通配符： <code>*0...</code></p>\n</li>\n</ol>\n<p>正如声明式查询语言的一贯特点，你只需描述问题，不必担心执行过程。但与 SQL 的区别在于，SQL 基于关系代数，Cypher 类似正则表达式。</p>\n<p>无论是 BFS、DFS 还是剪枝等实现细节，一般来说（但是不同厂商通常都会有不同的最佳实践），用户都不需要关心。</p>\n<h3 id=\"SQL中的图查询\"><a href=\"#SQL中的图查询\" class=\"headerlink\" title=\"SQL中的图查询\"></a>SQL中的图查询</h3><p>在上文中，我们可以用 SQL 存储点和边，以表示图。</p>\n<p>那么也可以用 SQL 进行图查询</p>\n<p>Oracle 的 <a href=\"https://docs.oracle.com/en/database/oracle/property-graph/20.4/spgdg/property-graph-query-language-pgql.html\">PGQL</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> PROPERTY GRAPH bank_transfers</span><br><span class=\"line\">     VERTEX TABLES (persons KEY(account_number))</span><br><span class=\"line\">     EDGE TABLES(</span><br><span class=\"line\">                  transactions KEY (from_acct, to_acct, <span class=\"type\">date</span>, amount)</span><br><span class=\"line\">                  SOURCE KEY (from_account) <span class=\"keyword\">REFERENCES</span> persons</span><br><span class=\"line\">                  DESTINATION KEY (to_account) <span class=\"keyword\">REFERENCES</span> persons</span><br><span class=\"line\">                  PROPERTIES (<span class=\"type\">date</span>, amount)</span><br><span class=\"line\">       )</span><br></pre></td></tr></table></figure>\n\n<p>其中有一个难点，就是如何表达图中的路径模式（graph pattern），如多跳查询，对应到 SQL 中，就是不确定次数的 Join：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() <span class=\"operator\">-</span>[:<span class=\"keyword\">WITHIN</span><span class=\"operator\">*</span><span class=\"number\">0.</span>.]<span class=\"operator\">-</span><span class=\"operator\">&gt;</span> ()</span><br></pre></td></tr></table></figure>\n\n<p>自 SQL:1999，查询可变长度遍历路径的思想可以使用称为 递归公用表表达式（<code>WITH RECURSIVE</code> 语法）的东西来表示。显示了同样的查询 - 查找从美国移民到欧洲的人的姓名 - 在 SQL 使用这种技术（PostgreSQL、IBM DB2、Oracle 和 SQL Server 均支持）来表述。但是与 Cypher 相比，它的语法相当冗长，笨拙。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WITH</span> <span class=\"keyword\">RECURSIVE</span></span><br><span class=\"line\">  <span class=\"comment\">-- in_usa 包含所有的美国境内的位置 ID</span></span><br><span class=\"line\">    in_usa(vertex_id) <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> vertex_id <span class=\"keyword\">FROM</span> vertices <span class=\"keyword\">WHERE</span> properties <span class=\"operator\">-</span><span class=\"operator\">&gt;&gt;</span> <span class=\"string\">'name'</span> <span class=\"operator\">=</span> <span class=\"string\">'United States'</span></span><br><span class=\"line\">    <span class=\"keyword\">UNION</span></span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> edges.tail_vertex <span class=\"keyword\">FROM</span> edges</span><br><span class=\"line\">      <span class=\"keyword\">JOIN</span> in_usa <span class=\"keyword\">ON</span> edges.head_vertex <span class=\"operator\">=</span> in_usa.vertex_id</span><br><span class=\"line\">      <span class=\"keyword\">WHERE</span> edges.label <span class=\"operator\">=</span> <span class=\"string\">'within'</span></span><br><span class=\"line\">  ),</span><br><span class=\"line\">  <span class=\"comment\">-- in_europe 包含所有的欧洲境内的位置 ID</span></span><br><span class=\"line\">    in_europe(vertex_id) <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> vertex_id <span class=\"keyword\">FROM</span> vertices <span class=\"keyword\">WHERE</span> properties <span class=\"operator\">-</span><span class=\"operator\">&gt;&gt;</span> <span class=\"string\">'name'</span> <span class=\"operator\">=</span> <span class=\"string\">'Europe'</span></span><br><span class=\"line\">    <span class=\"keyword\">UNION</span></span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> edges.tail_vertex <span class=\"keyword\">FROM</span> edges</span><br><span class=\"line\">      <span class=\"keyword\">JOIN</span> in_europe <span class=\"keyword\">ON</span> edges.head_vertex <span class=\"operator\">=</span> in_europe.vertex_id</span><br><span class=\"line\">      <span class=\"keyword\">WHERE</span> edges.label <span class=\"operator\">=</span> <span class=\"string\">'within'</span> ),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">-- born_in_usa 包含了所有类型为 Person，且出生在美国的顶点</span></span><br><span class=\"line\">    born_in_usa(vertex_id) <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">      <span class=\"keyword\">SELECT</span> edges.tail_vertex <span class=\"keyword\">FROM</span> edges</span><br><span class=\"line\">        <span class=\"keyword\">JOIN</span> in_usa <span class=\"keyword\">ON</span> edges.head_vertex <span class=\"operator\">=</span> in_usa.vertex_id</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> edges.label <span class=\"operator\">=</span> <span class=\"string\">'born_in'</span> ),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">-- lives_in_europe 包含了所有类型为 Person，且居住在欧洲的顶点。</span></span><br><span class=\"line\">    lives_in_europe(vertex_id) <span class=\"keyword\">AS</span> (</span><br><span class=\"line\">      <span class=\"keyword\">SELECT</span> edges.tail_vertex <span class=\"keyword\">FROM</span> edges</span><br><span class=\"line\">        <span class=\"keyword\">JOIN</span> in_europe <span class=\"keyword\">ON</span> edges.head_vertex <span class=\"operator\">=</span> in_europe.vertex_id</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> edges.label <span class=\"operator\">=</span> <span class=\"string\">'lives_in'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> vertices.properties <span class=\"operator\">-</span><span class=\"operator\">&gt;&gt;</span> <span class=\"string\">'name'</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> vertices</span><br><span class=\"line\">    <span class=\"keyword\">JOIN</span> born_in_usa <span class=\"keyword\">ON</span> vertices.vertex_id <span class=\"operator\">=</span> born_in_usa.vertex_id</span><br><span class=\"line\">    <span class=\"keyword\">JOIN</span> lives_in_europe <span class=\"keyword\">ON</span> vertices.vertex_id <span class=\"operator\">=</span> lives_in_europe.vertex_id;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三元组存储和SPARQL\"><a href=\"#三元组存储和SPARQL\" class=\"headerlink\" title=\"三元组存储和SPARQL\"></a>三元组存储和SPARQL</h3><h4 id=\"三元组存储（Triple-Stores）\"><a href=\"#三元组存储（Triple-Stores）\" class=\"headerlink\" title=\"三元组存储（Triple-Stores）\"></a>三元组存储（Triple-Stores）</h4><p>在三元组存储中，所有信息都以非常简单的三部分表示形式存储（主语，谓语，宾语）。例如，三元组 (吉姆, 喜欢, 香蕉) 中，吉姆 是主语，喜欢 是谓语（动词），香蕉 是对象。</p>\n<table>\n<thead>\n<tr>\n<th>Subject</th>\n<th>对应图中的一个点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Object</td>\n<td>1. 一个原子数据，如 string 或者 number。  \n2. 另一个 Subject。</td>\n</tr>\n<tr>\n<td>Predicate</td>\n<td>1. 如果 Object 是原子数据，则 <code>&lt;Predicate, Object&gt;</code> 对应点附带的 KV 对。2. 如果 Object 是另一个 Object，则 Predicate 对应图中的边。</td>\n</tr>\n</tbody></table>\n<p>仍是上边例子，用 Turtle triples (一种 Triple-Stores 语法）表达为：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@prefix : &lt;urn:example:&gt;.</span><br><span class=\"line\">_:lucy     a       :Person.</span><br><span class=\"line\">_:lucy     :name   \"Lucy\".</span><br><span class=\"line\">_:lucy     :bornIn _:idaho.</span><br><span class=\"line\">_:idaho    a       :Location.</span><br><span class=\"line\">_:idaho    :name   \"Idaho\".</span><br><span class=\"line\">_:idaho    :type   \"state\".</span><br><span class=\"line\">_:idaho    :within _:usa.</span><br><span class=\"line\">_:usa      a       :Location</span><br><span class=\"line\">_:usa      :name   \"United States\"</span><br><span class=\"line\">_:usa      :type   \"country\".</span><br><span class=\"line\">_:usa      :within _:namerica.</span><br><span class=\"line\">_:namerica a       :Location.</span><br><span class=\"line\">_:namerica :name   \"North America\".</span><br><span class=\"line\">_:namerica :type   \"continent\".</span><br></pre></td></tr></table></figure>\n\n<p>一种更紧凑的写法：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@prefix : &lt;urn:example:&gt;.</span><br><span class=\"line\">_:lucy     a: Person;   :name \"Lucy\";          :bornIn _:idaho</span><br><span class=\"line\">_:idaho    a: Location; :name \"Idaho\";         :type \"state\";     :within _:usa.</span><br><span class=\"line\">_:usa      a: Location; :name \"United States\"; :type \"country\";   :within _:namerica.</span><br><span class=\"line\">_:namerica a :Location; :name \"North America\"; :type \"continent\".</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"语义网（The-Semantic-Web）\"><a href=\"#语义网（The-Semantic-Web）\" class=\"headerlink\" title=\"语义网（The Semantic Web）\"></a>语义网（The Semantic Web）</h4><p>由万维网之父 Tim Berners Lee 于 1998 年提出，知识图谱前身。其目的在于对网络中的资源进行结构化，从而让计算机能够理解网络中的数据。即不是以文本、二进制流等非结构数据呈现内容，而是以某种标准结构化互联网上通过超链接而关联的数据。</p>\n<p>语义：提供一种统一的方式对所有资源进行描述和结构化（机器可读）。</p>\n<p>网：将所有资源勾连起来。</p>\n<p>下面是语义网技术栈（Semantic Web Stack）：</p>\n<p><a href=\"images/image-2.png\"></a></p>\n<p>其中 RDF （ <em>ResourceDescription Framework，资源描述框架</em> ）提供了一种结构化网络中数据的标准。使发布到网络中的任何资源（文字、图片、视频、网页），都能以统一的形式被计算机理解。从另一个角度来理解，即，不需要资源使用方通过深度学习等方式来抽取语义，而是靠资源提供方通过 RDF 主动提供其资源语义。</p>\n<p>不幸的是，语义网在二十一世纪初被过度炒作，但到目前为止没有任何迹象表明已在实践中应用，这使得许多人嗤之以鼻。它还饱受眼花缭乱的缩略词、过于复杂的标准提案和狂妄自大的困扰。</p>\n<p>虽然语义网没有发展起来，但是其中间数据交换格式 RDF 所定义的 SPO 三元组 (Subject-Predicate-Object) 却是一种很好用的数据模型，也就是上面提到的 Triple-Stores。</p>\n<h4 id=\"RDF数据模型\"><a href=\"#RDF数据模型\" class=\"headerlink\" title=\"RDF数据模型\"></a>RDF数据模型</h4><p>上面提到的 Turtle 语言（SPO 三元组）是一种简单易读的描述 RDF 数据的方式，RDF 也可以基于 XML 表示，但是要冗余难读的多（嵌套太深）：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;rdf:RDF xmlns=\"urn:example:\"xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"&gt;</span><br><span class=\"line\">    &lt;Location rdf:nodeID=\"idaho\"&gt;</span><br><span class=\"line\">        &lt;name&gt;Idaho&lt;/name&gt;</span><br><span class=\"line\">        &lt;type&gt;state&lt;/type&gt;</span><br><span class=\"line\">        &lt;within&gt;</span><br><span class=\"line\">            &lt;Location rdf:nodeID=\"usa\"&gt;</span><br><span class=\"line\">                &lt;name&gt;United States&lt;/name&gt;</span><br><span class=\"line\">                &lt;type&gt;country&lt;/type&gt;</span><br><span class=\"line\">                &lt;within&gt;</span><br><span class=\"line\">                    &lt;Location rdf:nodeID=\"namerica\"&gt;</span><br><span class=\"line\">                        &lt;name&gt;North America&lt;/name&gt;</span><br><span class=\"line\">                        &lt;type&gt;continent&lt;/type&gt;</span><br><span class=\"line\">                &lt;/Location&gt;</span><br><span class=\"line\">            &lt;/within&gt;</span><br><span class=\"line\">      &lt;/Location&gt;</span><br><span class=\"line\">    &lt;/within&gt;</span><br><span class=\"line\">    &lt;/Location&gt;</span><br><span class=\"line\">    &lt;Person rdf:nodeID=\"lucy\"&gt;</span><br><span class=\"line\">        &lt;name&gt;Lucy&lt;/name&gt;</span><br><span class=\"line\">        &lt;bornIn rdf:nodeID=\"idaho\"/&gt;</span><br><span class=\"line\">    &lt;/Person&gt;</span><br><span class=\"line\">&lt;/rdf:RDF&gt;</span><br></pre></td></tr></table></figure>\n\n<p>为了标准化和去除二义性，一些看起来比较奇怪的点是：无论 subject，predicate 还是 object 都是由 URI 定义，如</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lives_in 会表示为 &lt;http://my-company.com/namespace#lives_in&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其前缀只是一个 namespace，让定义唯一化，并且在网络上可访问。</p>\n<h4 id=\"SPARQL-查询语言\"><a href=\"#SPARQL-查询语言\" class=\"headerlink\" title=\"SPARQL 查询语言\"></a>SPARQL 查询语言</h4><p>有了语义网，自然需要在语义网中进行遍历查询，于是有了 RDF 的查询语言：SPARQL Protocol and RDF Query Language, 读作“sparkle.”</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PREFIX : &lt;urn:example:&gt;</span><br><span class=\"line\">SELECT ?personName WHERE {</span><br><span class=\"line\">  ?person :name ?personName.</span><br><span class=\"line\">  ?person :bornIn  / :within* / :name \"United States\".</span><br><span class=\"line\">  ?person :livesIn / :within* / :name \"Europe\".</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>他是 Cypher 的前驱，因此二者的结构看起来很相似：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (location)   # Cypher</span><br><span class=\"line\">?person   :bornIn /        :within*        ?location.   # SPARQL</span><br></pre></td></tr></table></figure>\n\n<p>但 SPARQL 没有区分边和属性的关系，都用了 Predicates。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(usa {name:'United States'})   # Cypher</span><br><span class=\"line\">?usa :name \"United States\".    # SPARQL</span><br></pre></td></tr></table></figure>\n\n<p>虽然语义网没有成功落地，但其技术栈影响了后来的知识图谱和图查询语言。</p>\n<h3 id=\"图模型vs网络模型\"><a href=\"#图模型vs网络模型\" class=\"headerlink\" title=\"图模型vs网络模型\"></a>图模型vs网络模型</h3><table>\n<thead>\n<tr>\n<th>模型</th>\n<th>图模型 (Graph Model)</th>\n<th>网络模型 (Network Model)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>连接方式</td>\n<td>任意两个点之间都可以有边</td>\n<td>指定了嵌套约束</td>\n</tr>\n<tr>\n<td>记录查找</td>\n<td>1. 使用全局 ID2. 使用属性索引3. 使用图遍历</td>\n<td>只能使用路径查询</td>\n</tr>\n<tr>\n<td>有序性</td>\n<td>点和边都是无序的</td>\n<td>记录的孩子们是有序集合，在插入时需要考虑怎样维护有序的开销</td>\n</tr>\n<tr>\n<td>查询语言</td>\n<td>即可命令式，也可以声明式</td>\n<td>命令式的</td>\n</tr>\n</tbody></table>\n<h3 id=\"Datalog\"><a href=\"#Datalog\" class=\"headerlink\" title=\"Datalog\"></a>Datalog</h3><p>有点像 triple-store，但是变了下次序：(<em>subject</em>, <em>predicate</em>, <em>object</em>) -&gt; <em>predicate</em>(<em>subject</em>, <em>object</em>). 之前数据用 Datalog 表示为：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name(namerica, 'North America').</span><br><span class=\"line\">type(namerica, continent).</span><br><span class=\"line\">name(usa, 'United States').</span><br><span class=\"line\">type(usa, country).</span><br><span class=\"line\">within(usa, namerica).</span><br><span class=\"line\">name(idaho, 'Idaho').</span><br><span class=\"line\">type(idaho, state).</span><br><span class=\"line\">within(idaho, usa).</span><br><span class=\"line\">name(lucy, 'Lucy').</span><br><span class=\"line\">born_in(lucy, idaho).</span><br></pre></td></tr></table></figure>\n\n<p>查询从<em>美国迁移到欧洲的人</em>可以表示为：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">within_recursive(Location, Name) :- name(Location, Name). /* Rule 1 */</span><br><span class=\"line\">within_recursive(Location, Name) :- within(Location, Via), /* Rule 2 */</span><br><span class=\"line\">                                    within_recursive(Via, Name).</span><br><span class=\"line\">migrated(Name, BornIn, LivingIn) :- name(Person, Name), /* Rule 3 */</span><br><span class=\"line\">                                    born_in(Person, BornLoc),</span><br><span class=\"line\">                                    within_recursive(BornLoc, BornIn),</span><br><span class=\"line\">                                    lives_in(Person, LivingLoc),</span><br><span class=\"line\">                                    within_recursive(LivingLoc, LivingIn).</span><br><span class=\"line\">?- migrated(Who, 'United States', 'Europe'). /* Who = 'Lucy'. */</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>代码中以大写字母开头的元素是变量，字符串、数字或以小写字母开头的元素是常量。下划线（_）被称为匿名变量</p>\n</li>\n<li><p>可以使用基本 Predicate 自定义 Predicate，类似于使用基本函数自定义函数。</p>\n</li>\n<li><p>逗号连接的多个谓词表达式为且的关系。</p>\n</li>\n</ol>\n","categories":[{"name":"分布式","slug":"分布式","count":3,"path":"api/categories/分布式.json"},{"name":"DDIA","slug":"分布式/DDIA","count":3,"path":"api/categories/分布式/DDIA.json"}],"tags":[{"name":"分布式","slug":"分布式","count":3,"path":"api/tags/分布式.json"},{"name":"DDIA","slug":"DDIA","count":3,"path":"api/tags/DDIA.json"}]}