{"title":"GO语言内存模型","slug":"GO语言内存模型","date":"2025-04-14T01:22:42.000Z","updated":"2025-05-05T04:30:44.384Z","comments":true,"path":"api/articles/GO语言内存模型.json","photos":[],"excerpt":"先导本文将深入探讨 Go 语言的内存模型，特别是如何在并发编程中确保数据一致性和线程安全。首先，我们将介绍 Go 语言内存模型的核心概念，重点讲解内存操作如何通过明确的顺序和同步机制保证程序在多核处理器上正确执行。接下来，将详细阐述 Go 中的 “happens-before” 规则，说明如何通过 goroutine 间的同步避免数据竞争，确保读写操作的顺序一致性。此外，还会探讨什么是数据竞争，以及 Go 语言是如何检测并处理这些问题的。对于包含数据竞争的程序，Go 的实现会在检测到问题时报告错误并终止程序，以保证程序的稳定性。最后，内容会介绍一些常见的同步机制，如原子操作、互斥锁和通道通信，帮助开发者理解如何有效地同步多个 goroutine 之间的操作。通过本篇内容，读者将深入理解 Go 语言内存模型的工作原理，掌握如何编写高效、安全的并发程序，避免常见的同步问题。","covers":["/../Asset/GO%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Gopher.jpg"],"content":"<h1 id=\"先导\"><a href=\"#先导\" class=\"headerlink\" title=\"先导\"></a>先导</h1><p>本文将深入探讨 Go 语言的内存模型，特别是如何在并发编程中确保数据一致性和线程安全。首先，我们将介绍 Go 语言内存模型的核心概念，重点讲解内存操作如何通过明确的顺序和同步机制保证程序在多核处理器上正确执行。接下来，将详细阐述 Go 中的 “happens-before” 规则，说明如何通过 goroutine 间的同步避免数据竞争，确保读写操作的顺序一致性。</p>\n<p>此外，还会探讨什么是数据竞争，以及 Go 语言是如何检测并处理这些问题的。对于包含数据竞争的程序，Go 的实现会在检测到问题时报告错误并终止程序，以保证程序的稳定性。最后，内容会介绍一些常见的同步机制，如原子操作、互斥锁和通道通信，帮助开发者理解如何有效地同步多个 goroutine 之间的操作。</p>\n<p>通过本篇内容，读者将深入理解 Go 语言内存模型的工作原理，掌握如何编写高效、安全的并发程序，避免常见的同步问题。</p>\n<span id=\"more\"></span>\n<p><img src=\"/../Asset/GO%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Gopher.jpg\" alt=\"Gopher\"></p>\n<blockquote>\n<p>💡当涉及到存在竞态条件的程序时，程序员和编译器都应谨记这条建议：不要耍小聪明。</p>\n</blockquote>\n<h1 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h1><p>Go 语言的内存模型与Go语言的设计理念一致，力求保持语义简洁、易于理解且实用。</p>\n<blockquote>\n<p>数据竞争的定义是：对同一内存位置的写入操作与另一读取或写入操作并发发生，除非所有相关访问均为通过 <code>sync/atomic</code> 包提供的原子数据访问。如前所述，强烈建议程序员使用适当的同步机制避免数据竞争。</p>\n<p>在没有数据竞争的情况下，Go 程序的行为如同所有 goroutine 被复用到单个处理器上执行。这一特性有时被称为 DRF-SC：无数据竞争的程序以顺序一致的方式执行。</p>\n<p>尽管程序员应当编写无数据竞争的 Go 程序，但 Go 实现在应对数据竞争方面存在局限性。一种可能的实现选择在检测到数据竞争时报告该竞争并终止程序。</p>\n</blockquote>\n<p>内存模型描述了程序执行所需满足的条件，这些程序的执行由 goroutine 的执行组成，而 goroutine 的执行又由内存操作构成。</p>\n<p>内存操作通过四个要素进行建模</p>\n<ul>\n<li><p>它的类型，表明它是普通数据读取、普通数据写入，还是同步操作（如原子数据访问、互斥锁操作或通道操作）</p>\n</li>\n<li><p>它在程序中的位置</p>\n</li>\n<li><p>被访问的内存位置或变量</p>\n</li>\n<li><p>操作所读取或写入的值</p>\n</li>\n</ul>\n<p>一些内存操作属于读取类，包括读取、原子读取、互斥锁锁定和通道接收。另外一些内存操作属于写入类，包括写入、原子写入、互斥锁解锁、通道发送和通道关闭。还有一些操作，如原子交换，同时具备读取和写入的特性。</p>\n<p>一个 goroutine 的执行被建模为单个 goroutine 执行的一系列内存操作。</p>\n<h2 id=\"要求1\"><a href=\"#要求1\" class=\"headerlink\" title=\"要求1\"></a>要求1</h2><p>每个 goroutine 中的内存操作必须按照特定的正确顺序执行（基于从内存读取和写入的值），这个顺序与该goroutine相对应。该执行必须与“先于”关系保持一致。</p>\n<blockquote>\n<p>Go 语言有一个非常重要的内存顺序要求（叫做 “happens-before”），它规定了在不同 goroutine 中执行的操作必须遵循特定的顺序。简单来说，它描述一个操作 <strong>必须先于</strong> 另一个操作发生的要求。</p>\n</blockquote>\n<p>Go 程序的执行被建模为一组 goroutine 的执行，以及一个映射 W，该映射使得程序中的每个读操作都有一个明确的写操作与之对应</p>\n<blockquote>\n<p>确保读操作读到了一个对应的写操作所写入的值。举个例子，如果在某个 goroutine 中写了数据，然后又读了这个数据，那么写操作必须先于读操作发生。这样，读操作才能看到写操作的结果。</p>\n</blockquote>\n<p>同一程序的每次执行中，goroutine 之间的调度顺序可能不同，但是仍然符合Go语言规范</p>\n<h2 id=\"要求2\"><a href=\"#要求2\" class=\"headerlink\" title=\"要求2\"></a>要求2</h2><p>对于给定的程序执行，当映射 W 仅限于同步操作时，必须能够通过某种隐式的同步操作全序来解释，该全序需与操作间的顺序关系以及这些操作读写的数据值保持一致。</p>\n<p>同步先序关系是从 W 派生的关于同步内存操作的一个偏序关系。如果同步读类的内存操作 r 观察到同步写类的内存操作 w（即 W(r) = w），那么 w 同步先于 r。非正式地说，同步先序关系是隐含全序关系的子集，仅限于 W 直接观察到的信息。</p>\n<p>先序关系被定义为顺序先序关系与同步先序关系并集的传递闭包。</p>\n<h2 id=\"要求3\"><a href=\"#要求3\" class=\"headerlink\" title=\"要求3\"></a>要求3</h2><p>对于内存位置 x 上的普通（非同步）数据读取 r，W(r)必须是一个对 r 可见的写操作 w，其中“可见”意味着以下两个条件同时成立：</p>\n<ol>\n<li><p> w 先于 r 发生</p>\n</li>\n<li><p>针对变量 x，在写操作 w 和读操作 r 之间不会发生任何写操作 w’。</p>\n</li>\n</ol>\n<p>内存位置 x 上的读-写数据竞争，由对 x 的读类内存操作 r 和写类内存操作 w 造成，其中至少有一个是非同步操作，且两者之间不存在”先于”关系（即 r 不先于 w，w 也不先于 r）。</p>\n<p>内存位置 x 上的写-写数据竞争，由对 x 的两个写类内存操作 w 和 w’ 造成，其中至少有一个是非同步操作，且两者之间不存在”先于”关系。</p>\n<p>注意，如果内存位置 x 上不存在读-写或写-写数据竞争，那么对 x 的任何读操作 r 仅有一个可能的 W(r)：即在”先于”顺序中紧邻其前的唯一写操作 w。</p>\n<p>更一般地说，可以证明任何无数据竞争的 Go 程序——即不存在读写或写写数据竞争的程序执行——其所有结果都能通过某种 goroutine 执行的顺序一致性交错来解释。（证明方法与上文引用的 Boehm 和 Adve 论文第 7 节相同。）这一特性被称为 DRF-SC。</p>\n<h1 id=\"实现对包含有数据竞争的程序的限制\"><a href=\"#实现对包含有数据竞争的程序的限制\" class=\"headerlink\" title=\"实现对包含有数据竞争的程序的限制\"></a>实现对包含有数据竞争的程序的限制</h1><p>前文章节给出了无数据竞争程序执行的正式定义。本节非正式地描述了实现必须为存在竞争的程序提供的语义。</p>\n<p>任何实现都可以在检测到数据竞争时报告该竞争并停止程序的执行。使用 ThreadSanitizer（通过“ <code>go build -race</code> ”访问）的实现正是这样做的。</p>\n<p>对数组、结构体或复数的读取可能被实现为以任意顺序逐个读取其内部的值（数组元素、结构体字段或实部/虚部）。类似地，对数组、结构体或复数的写入也可能被实现为以任意顺序独立地写入它们的内部值。</p>\n<p>对于内存位置 x 的读取操作 r，若该位置存储的值不大于一个机器字长，则必须观察到某个写入操作 w，使得 r 不会在 w 之前发生，并且不存在另一个写入操作 w’ ，使得 w’ 在 w 和 r 之间发生。也就是说，每个读取操作必须观察到一个由先前的或并发的写操作写入的值。</p>\n<p>此外，不允许观察到无因果关系的或“凭空出现”的写操作。</p>\n<p>而对于对于大于单个机器字长的内存位置读取，虽然建议其遵循与单个机器字长内存位置相同的读取语义（即只观察一个有效的写入操作），但这并不是强制要求。</p>\n<p>出于性能考虑，某些实现可能会将大于机器字长的数据操作拆分为多个独立的、较小的操作（每个操作的大小等于机器字长）。这些拆分的小操作可能以任意顺序执行，这可能会导致不一致的行为。</p>\n<p>当多个线程或操作并发地对一个多字节的数据结构进行访问时，可能会出现竞态。读取到的值可能与单个完整的写操作的值不一致，导致读取到不正确的值。</p>\n<p>某些数据结构（如 接口、映射、切片和字符串）内部包含了指针、长度、类型等信息。如果多个并发操作引发竞态条件，使得内部的指针、长度等信息不一致，就可能无法正确地解释数据。</p>\n<p>错误的同步示例在下面的“不正确同步”部分给出。</p>\n<p>实现限制的示例在下面的“不正确编译”部分给出。</p>\n<h1 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ul>\n<li><p>程序初始化在单个 goroutine 中运行，但该 goroutine 可能会创建其他并发运行的 goroutine。</p>\n</li>\n<li><p>如果包 <code>p</code> 导入了包 <code>q</code> ，则 <code>q</code> 的 <code>init</code> 函数的完成发生在 <code>p</code> 的任何函数开始之前。</p>\n</li>\n<li><p>所有 <code>init</code> 函数的完成在函数 <code>main.main</code> 开始之前同步。</p>\n</li>\n</ul>\n<h2 id=\"goroutine的创建\"><a href=\"#goroutine的创建\" class=\"headerlink\" title=\"goroutine的创建\"></a>goroutine的创建</h2><p>启动新 goroutine 的 <code>go</code> 语句在该 goroutine 执行开始之前同步完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> f()</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>hello</code> 将在未来的某个时刻（可能在 <code>hello</code> 返回之后）打印 <code>\"hello, world\"</code> 。</p>\n<h2 id=\"goroutine的销毁\"><a href=\"#goroutine的销毁\" class=\"headerlink\" title=\"goroutine的销毁\"></a>goroutine的销毁</h2><p>但是无法保证 goroutine 的退出会在程序中任何事件之前同步完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> { a = <span class=\"string\">\"hello\"</span> }()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>对 <code>a</code> 的赋值操作后未跟随任何同步事件，因此不能保证其他 goroutine 能观察到这一操作。实际上，激进的编译器可能会删除整个 <code>go</code> 语句。</p>\n<p>若必须让一个 goroutine 的效果被另一个 goroutine 观察到，应使用锁或通道通信等同步机制来建立相对顺序。</p>\n<h2 id=\"通道通信\"><a href=\"#通道通信\" class=\"headerlink\" title=\"通道通信\"></a>通道通信</h2><p>通道通信是 goroutine 之间同步的主要方式。特定通道上的每次发送都会与该通道上对应的接收操作匹配，两种操作通常发生在不同的 goroutine 中。</p>\n<p>通道上的发送操作会在对应接收操作完成之前同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 创建一个缓冲大小为 10 的通道</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        c &lt;- <span class=\"number\">0</span> <span class=\"comment\">// 发送一个值到通道 c</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> f() <span class=\"comment\">// 启动一个新的 goroutine 执行 f()</span></span><br><span class=\"line\">        &lt;-c <span class=\"comment\">// 从通道 c 接收数据，等待 f() 完成发送</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>此程序保证会打印 <code>\"hello, world\"</code> 。对 <code>a</code> 的写入在发送到 <code>c</code> 之前已排序，而发送操作与对应的 <code>c</code> 上的接收完成同步，该接收又在 <code>print</code> 之前排序。</p>\n<p>通道的关闭操作会同步于因通道关闭而返回零值的接收操作之前完成。</p>\n<p>将 <code>c &lt;- 0</code> 替换为 <code>close(c)</code> 会生成一个具有相同保证行为的程序。</p>\n<p>从无缓冲通道的接收操作，会先于该通道上对应发送操作的完成而同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) <span class=\"comment\">// 创建一个无缓冲的通道</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        &lt;-c <span class=\"comment\">// 由于这是一个 无缓冲通道，接收操作会阻塞，直到有其他地方发送数据到该通道。</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> f()</span><br><span class=\"line\">        c &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>此程序同样保证会打印 <code>\"hello, world\"</code> 。对 <code>a</code> 的写入先于在 <code>c</code> 上的接收操作，而该接收操作又先于对应在 <code>c</code> 上的发送操作完成而同步，后者再先于 <code>print</code> 。</p>\n<p>如果通道是带缓冲的（例如， <code>c = make(chan int, 1)</code> ），那么程序将无法保证打印出 <code>\"hello, world\"</code> 。（它可能打印空字符串、崩溃或执行其他操作。）</p>\n<p>因为 <strong>带缓冲通道</strong> 不会像无缓冲通道那样强制同步发送和接收操作。缓冲通道允许发送操作在没有对应接收操作的情况下完成。这样，<code>main()</code> 函数中的 <code>c &lt;- 0</code> 可能会在 <code>f()</code> 函数中的接收操作之前就完成，这样就不会保证 <code>a = \"hello, world\"</code> 在 <code>print(a)</code> 之前已经执行。</p>\n<p>在容量为 C 的通道上，第 k 次接收操作会在第 k+C 次发送操作完成之前同步完成。</p>\n<p>此规则将前一条规则推广至带缓冲的通道。它允许通过带缓冲的通道模拟计数信号量：通道中的项目数对应活跃使用的数量，通道的容量对应同时使用的最大数量，发送项目获取信号量，接收项目释放信号量。这是限制并发性的常见惯用法。</p>\n<p>该程序为工作列表中的每个条目启动一个 goroutine，但 goroutines 通过 <code>limit</code> 通道协调，确保最多有三个同时运行工作函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> limit = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> work {</span><br><span class=\"line\">                <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w <span class=\"keyword\">func</span>()</span></span>) {</span><br><span class=\"line\">                        limit &lt;- <span class=\"number\">1</span> <span class=\"comment\">// 获取信号量，限制同时运行的 goroutines 数量</span></span><br><span class=\"line\">                        w()        <span class=\"comment\">// 执行工作函数</span></span><br><span class=\"line\">                        &lt;-limit    <span class=\"comment\">// 释放信号量</span></span><br><span class=\"line\">                }(w)</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">select</span>{} <span class=\"comment\">// 使 main() 函数阻塞，直到程序结束。</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p><code>sync</code> 包实现了两种锁数据类型， <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 。</p>\n<p>对于任何 <code>sync.Mutex</code> 或 <code>sync.RWMutex</code> 变量 <code>l</code> ，且 n &lt; m 时，第 n 次调用 <code>l.Unlock()</code> 会在第 m 次调用 <code>l.Lock()</code> 返回之前同步完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> l sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        l.Unlock()</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        l.Lock()</span><br><span class=\"line\">        <span class=\"keyword\">go</span> f()</span><br><span class=\"line\">        l.Lock()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>保证会打印 <code>\"hello, world\"</code> 。第一次调用 <code>l.Unlock()</code> （在 <code>f</code> 中）与第二次调用 <code>l.Lock()</code> （在 <code>main</code> 中）返回之前同步发生，后者又先于 <code>print</code> 的顺序执行。</p>\n<p>对于任何对 <code>sync.RWMutex</code> 变量 <code>l</code> 的 <code>l.RLock</code> 调用，存在一个 n，使得第 n 次调用 <code>l.Unlock</code> 与 <code>l.RLock</code> 返回之前同步发生，而对应的 <code>l.RUnlock</code> 调用则与第 n+1 次调用 <code>l.Lock</code> 返回之前同步发生。</p>\n<p>成功的 <code>l.TryLock</code> （或 <code>l.TryRLock</code> ）调用等同于调用 <code>l.Lock</code> （或 <code>l.RLock</code> ）。失败的调用完全不产生同步效果。就内存模型而言，即使互斥锁 <code>l</code> 未锁定， <code>l.TryLock</code> （或 <code>l.TryRLock</code> ）也可能被认为能够返回 false。</p>\n<h2 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h2><p><code>sync</code> 包通过使用 <code>Once</code> 类型，为多 goroutine 环境下的初始化提供了一种安全机制。多个线程可以针对特定的 <code>f</code> 执行 <code>once.Do(f)</code> ，但只有一个会运行 <code>f()</code> ，其他调用将阻塞，直到 <code>f()</code> 返回。</p>\n<p>从<code>once.Do(f)</code> 完成对单次 <code>f()</code> 调用的发起，会与任何 <code>once.Do(f)</code> 调用的返回之前同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doprint</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        once.Do(setup)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoprint</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">        <span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>twoprint</code> 将确保 <code>setup</code> 被精确调用一次。 <code>setup</code> 函数会在任一 <code>print</code> 调用之前完成。结果将是 <code>\"hello, world\"</code> 会被打印两次。</p>\n<h2 id=\"原子值\"><a href=\"#原子值\" class=\"headerlink\" title=\"原子值\"></a>原子值</h2><p><code>sync/atomic</code> 包中的 API 统称为“原子操作”，可用于同步不同 goroutine 的执行。如果原子操作 A 的效果被原子操作 B 观察到，那么 A 在 B 之前同步执行。程序中执行的所有原子操作的行为都像是在某种顺序一致的顺序中执行的。</p>\n<h2 id=\"终结器finalizer\"><a href=\"#终结器finalizer\" class=\"headerlink\" title=\"终结器finalizer\"></a>终结器finalizer</h2><p><code>runtime</code> 包提供了 <code>SetFinalizer</code> 函数，用于为特定对象添加终结器，当该对象不再被程序访问时将被调用。对 <code>SetFinalizer(x, f)</code> 的调用会在终结函数 <code>f(x)</code> 执行前同步完成。</p>\n<h2 id=\"其他机制\"><a href=\"#其他机制\" class=\"headerlink\" title=\"其他机制\"></a>其他机制</h2><p><code>sync</code> 包提供了额外的同步抽象机制，包括条件变量、无锁映射、分配池和等待组。每个机制的文档都详细说明了其在同步方面提供的保证。</p>\n<p>其他提供同步抽象机制的包也应明确其提供的保证。</p>\n<h1 id=\"不正确的同步\"><a href=\"#不正确的同步\" class=\"headerlink\" title=\"不正确的同步\"></a>不正确的同步</h1><p>存在数据竞争的程序是错误的，可能表现出非顺序一致的执行行为。特别需要注意的是，一个读操作 r 可能会观察到与它并发执行的任意写操作 w 所写入的值。即使这种情况发生，也不意味着在 r 之后发生的读操作会观察到 w 之前发生的写操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"number\">1</span></span><br><span class=\"line\">        b = <span class=\"number\">2</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> f()</span><br><span class=\"line\">        g()</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>在此程序中，可能会出现 <code>g</code> 打印 <code>2</code> 然后 <code>0</code> 的情况。</p>\n<blockquote>\n<p>虽然在代码中看起来 <code>a = 1</code> 和 <code>b = 2</code> 是顺序执行的，但在并发程序中，尤其是没有同步的情况下，它们的执行顺序可能并不会按照代码的顺序。</p>\n<p>编译器、处理器和运行时系统通常会对代码中的内存操作进行优化。为了提高性能，代码有可能会被重排进行。</p>\n<p>例如现代CPU支持乱序执行，即处理器会重新排列指令的执行顺序，以提高指令执行的效率。虽然程序员在源代码中指定了顺序（即 <code>a = 1</code> 先于 <code>b = 2</code>），但为了更高效地执行程序，CPU 可能会先执行 <code>b = 2</code>，然后执行 <code>a = 1</code>。</p>\n<p>没有显式同步的情况下，一个 goroutine 对内存的写操作可能不会立即对其他 goroutine 可见。即使两个写操作在程序中是顺序的，它们在内存中的顺序也可能被重排或延迟，使得其他 goroutine 看到不同于代码的顺序。</p>\n</blockquote>\n<p>双重检查锁定是一种试图避免同步开销的尝试。例如， <code>twoprint</code> 程序可能会被错误地写成</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        done = <span class=\"literal\">true</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doprint</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !done {</span><br><span class=\"line\">                once.Do(setup)</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoprint</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">        <span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>无法保证在 <code>doprint</code> 中观察到对 <code>done</code> 的写入就意味着能观察到对 <code>a</code> 的写入。此版本可能（错误地）打印空字符串而非 <code>\"hello, world\"</code> 。</p>\n<p>另一种错误的写法就是忙等待某个值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        a = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        done = <span class=\"literal\">true</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> setup()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> !done {</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>如前所述，无法保证在 <code>main</code> 中观察到对 <code>done</code> 的写入就意味着能观察到对 <code>a</code> 的写入，因此该程序同样可能打印空字符串。更糟的是，由于两个线程间缺乏同步事件，无法保证 <code>main</code> 会观察到对 <code>done</code> 的写入。 <code>main</code> 中的循环不保证能结束。</p>\n<p>包括这么写也是不正确的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> {</span><br><span class=\"line\">        msg <span class=\"type\">string</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g *T</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        t := <span class=\"built_in\">new</span>(T)</span><br><span class=\"line\">        t.msg = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        g = t</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br><span class=\"line\">        <span class=\"keyword\">go</span> setup()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> g == <span class=\"literal\">nil</span> {</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(g.msg)</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>即使 <code>main</code> 观察到 <code>g != nil</code> 并退出其循环，也无法保证它能观察到 <code>g.msg</code> 的初始化值。也就是说，可能在 <code>g</code> 被分配内存而未初始化的时候，<code>main</code> 就退出循环。</p>\n<p>以上所有的问题都需要通过显式地使用同步来解决</p>\n<h1 id=\"错误的编译\"><a href=\"#错误的编译\" class=\"headerlink\" title=\"错误的编译\"></a>错误的编译</h1><p>Go 内存模型对编译器优化的限制 与 对 Go 程序的限制同样严格。某些在单线程程序中有效的编译器优化，在所有 Go 程序中并不适用。具体而言，编译器不得引入原始程序中不存在的写入操作，不得允许单个读取操作观察到多个值，也不得允许单个写入操作写入多个值。</p>\n<p>以下所有示例均假设<code>*p</code>和<code>*q</code>指向多个 goroutine 可访问的内存位置。</p>\n<p>确保无数据竞争的程序不引入数据竞争，意味着不得将写操作移出它们所在的条件语句。例如，编译器绝不能反转以下程序中的条件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> cond {</span><br><span class=\"line\">        *p = <span class=\"number\">2</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，不能写成一下形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> !cond {</span><br><span class=\"line\">        *p = <span class=\"number\">1</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>cond</code> 为假且另一个 goroutine 正在读取 <code>*p</code> ，那么在原始程序中，该 goroutine 只能观察到 <code>*p</code> 和 <code>1</code> 的任何先前值。而在重写后的程序中，该 goroutine 可能观察到 <code>2</code> ，这在重写之前是不可能的。</p>\n<p>为了避免引入数据竞争，我们不能假设循环一定会终止。例如，编译器通常不得将访问 <code>*p</code> 或 <code>*q</code> 的操作移到以下程序的循环之前</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n := <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> e := list; e != <span class=\"literal\">nil</span>; e = e.next {</span><br><span class=\"line\">        n++</span><br><span class=\"line\">}</span><br><span class=\"line\">i := *p</span><br><span class=\"line\">*q = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>list</code> 指向一个循环链表，那么原始程序永远不会访问 <code>*p</code> 或 <code>*q</code> ，但改写后的程序则会访问。（若编译器能证明 <code>*p</code> 不会引发恐慌，将 <code>*p</code> 前移是安全的；而将 <code>*q</code> 前移还需编译器证明没有其他 goroutine 能访问 <code>*q</code> 。）</p>\n<p>为了避免引入数据竞争，我们也不能假设被调用的函数总会返回或不包含同步操作。例如，编译器不得将访问 <code>*p</code> 或 <code>*q</code> 的操作移到以下程序的函数调用之前（至少在没有直接了解 <code>f</code> 具体行为的情况下）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f()</span><br><span class=\"line\">i := *p</span><br><span class=\"line\">*q = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>如果该调用永不返回，那么原始程序同样永远不会访问 <code>*p</code> 或 <code>*q</code> ，但改写后的程序会访问。此外，如果调用中包含同步操作，原始程序可能在访问 <code>*p</code> 和 <code>*q</code> 之前建立 happens-before 顺序，而改写后的程序则不会。</p>\n<p>不允许单个读取操作观察到多个值，也就意味着不从共享内存中重新加载局部变量。例如，编译器不得在此程序中丢弃 <code>i</code> 并第二次从 <code>*p</code> 重新加载它：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := *p</span><br><span class=\"line\"><span class=\"keyword\">if</span> i &lt; <span class=\"number\">0</span> || i &gt;= <span class=\"built_in\">len</span>(funcs) {</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"invalid function index\"</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\">... <span class=\"built_in\">complex</span> code ...</span><br><span class=\"line\"><span class=\"comment\">// compiler must NOT reload i = *p here</span></span><br><span class=\"line\">funcs[i]()</span><br></pre></td></tr></table></figure>\n\n<p>如果复杂代码需要大量寄存器，单线程程序的编译器可能会在不保存副本的情况下丢弃 <code>i</code> ，然后在 <code>funcsi</code> 之前重新加载 <code>i = *p</code> 。但 Go 编译器不能这样做，因为 <code>*p</code> 的值可能已发生变化。（作为替代方案，编译器可以将 <code>i</code> 溢出到堆栈中。也就是说，当寄存器的空间不足时，编译器会将局部变量的值从寄存器中移到堆栈。）</p>\n<p>不允许单次写入多个值还意味着不能将即将写入局部变量的内存区域用作写入前的临时存储。例如，编译器不得在此程序中使用 <code>*p</code> 作为临时存储：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p = i + *p / <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是说，它不能将程序重写成这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p /= <span class=\"number\">2</span></span><br><span class=\"line\">*p += i</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>i</code> 和 <code>*p</code> 初始值均为 2，原代码执行 <code>*p = 3</code> ，因此竞态线程只能从 <code>*p</code> 读取到 2 或 3。而改写后的代码先执行 <code>*p = 1</code> 再执行 <code>*p = 3</code> ，使得竞态线程还可能读取到 1。</p>\n<blockquote>\n<p>💡请注意，所有这些优化在 C/C++编译器中都是允许的：与 C/C++编译器共享后端的 Go 编译器必须小心禁用那些对 Go 无效的优化。</p>\n</blockquote>\n<p>需要注意的是，如果编译器能够证明数据竞争不会影响目标平台上的正确执行，则禁止引入数据竞争的规则不适用。例如，在几乎所有 CPU 上，只要能够证明@0#在访问时不会出错，重写操作就是有效的，因为潜在增加的读取不会影响任何现有的并发读取或写入。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n := <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ {</span><br><span class=\"line\">        n += *shared</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>重写成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n := <span class=\"number\">0</span></span><br><span class=\"line\">local := *shared</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; m; i++ {</span><br><span class=\"line\">        n += local</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>前提是能够证明 <code>*shared</code> 在访问时不会引发错误，因为潜在的额外读取不会影响任何现有的并发读写操作。然而，这种重写在源代码到源代码的转换器中则无效。</p>\n","categories":[],"tags":[{"name":"Golang","slug":"Golang","count":1,"path":"api/tags/Golang.json"}]}